\documentclass[14pt]{beamer}

\usetheme{Warsaw}

\usepackage{listings}
\usepackage{jlcode}
\lstset{language=julia}

\usepackage{xeCJK}
\setCJKmainfont{HanWangWCL06}


\title{Metaprogramming in Julia}
\author{Iblis Lin}
\institute{}
\date{2018/8/11}


\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Introduction}
  粗淺的分類
  \begin{itemize}
    \item Text-based
      \begin{itemize}
        \item e.g. macro in C
      \end{itemize}
    \item Abstract Syntax Tree Level
      \begin{itemize}
        \item Lisp
        \item Julia
      \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}{Introduction}
  Metaprogramming 把程式本身視為 data 的一種
\end{frame}


\begin{frame}{Introduction}
  那麼有 data structure 跟 manipulations

  \pause
  在 Julia 中有 \alert{\texttt{Expr}} 這個 type
\end{frame}


\begin{frame}[fragile]{Construct Expressions}

julia 0.7/1.0:
\begin{lstlisting}
  julia> e = Meta.parse("42 + 1")
  :(42 + 1)
\end{lstlisting}

julia 0.6:
\begin{lstlisting}
  julia> e = parse("42 + 1")
  :(42 + 1)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Expressions}
\begin{lstlisting}
  julia> typeof(e)
  Expr
\end{lstlisting}

Fields of \texttt{Expr}:
\begin{itemize}
  \item \texttt{head::Symbol}
  \item \texttt{args::Array\{Any,1\}}
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Expressions}
\begin{lstlisting}
julia> e.head
:call

julia> e.args
3-element Array{Any,1}:
   :+
 42
  1
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Expressions}
  程式已經用 \texttt{Expr} 來表示了，那麼怎麼執行？

  \pause

\begin{lstlisting}
julia> e
:(42 + 1)

julia> eval(e)
43
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Expressions is mutable}

  所以可以各種改。

\begin{lstlisting}
  e.args[1] = :-
  e.args[3] = 50
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{其他生出 Expression 的方式}

  1. 直接 call constructor

\begin{lstlisting}
  Expr(:call, :+, 2, 3)
\end{lstlisting}

  \pause

  2. Quoting

\begin{lstlisting}
  :(1 + 2)
\end{lstlisting}
\begin{lstlisting}
  quote
    1 + 2
    2 + 3
  end
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]{Printing Expr Instance}
\begin{lstlisting}
  dump(e)
\end{lstlisting}

\begin{lstlisting}
  Meta.show_sexpr(e)
\end{lstlisting}

\end{frame}


\begin{frame}[c]{}
  \centering
  \Large
  The \texttt{Symbol} Type
\end{frame}


\begin{frame}[fragile]{Symbol}
  Like symbol in Lisp or atom in Erlang.

\begin{lstlisting}
  julia> :foo
  :foo

  julia> typeof(:foo)
  Symbol
\end{lstlisting}

  \pause

\begin{lstlisting}
  julia> Symbol("bar-1")
  Symbol("bar-1")
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Symbol}
  在 \texttt{Expr} 中的 identifier 會使用 symbol
  \begin{itemize}
    \item variable name
    \item function name
    \item ...
  \end{itemize}

  \pause
\begin{lstlisting}
  julia> e = :(x = 1)
  :(x = 1)

  julia> e.args
  2-element Array{Any,1}:
    :x
   1
\end{lstlisting}
\end{frame}


\begin{frame}[c]{}
  \centering
  \Large
  Interpolation

  \large
  動態的產生 \texttt{Expr} 的手段之一
\end{frame}


\begin{frame}[fragile]{Interpolation}
  用 \texttt{\$} 來 reference 外面的變數

  長得很像 string interpolation

\begin{lstlisting}
  julia> x = 42;

  julia> e = :($x + y)
  :(42 + y)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Splatting Interpolation}
  可以展開整個 array

\begin{lstlisting}
  julia> A
  3-element Array{Symbol,1}:
   :x
   :y
   :z

  julia> e = :(f($(A...)))
  :(f(x, y, z))
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Eval and Scope}
  打開 REPL 後，我在哪裡？

  \pause

\begin{lstlisting}
  julia> @__MODULE__
  Main
\end{lstlisting}

  \pause

\begin{lstlisting}
  foo = 1
  e = :(foo += 42)
  eval(e)
\end{lstlisting}

  請問現在 \texttt{foo} 是多少？
\end{frame}

\begin{frame}[fragile]{Eval and Scope}
  \texttt{eval} 的影響範圍是 module 的 global scope

\begin{lstlisting}
  function f()
    e = :(foo -= 100)
    eval(e)
  end

  foo = 1
  f()
\end{lstlisting}
\end{frame}

\end{document}
